/**
 * Rate Limit Manager
 * 
 * Manages failed authentication attempts and account lockout logic
 * to protect against brute force attacks.
 */

import { secureStorage } from './secureStorage';
import { securityStateManager, SecurityStateRecord } from './securityStateManager';
import { securityLogger, SecurityEventType } from './securityLogger';

export interface RateLimitStatus {
  isLocked: boolean;
  remainingTime?: number;
  attemptsRemaining?: number;
  canAttempt: boolean;
  progressiveDelay?: number;
}

export interface RateLimitConfig {
  maxAttempts: number;
  lockoutDuration: number; // in milliseconds
  progressiveDelay: boolean;
  storageKey: string;
  baseDelay?: number; // base delay in milliseconds for progressive delays
}

export interface SecurityState {
  failedAttempts: number;
  lockoutUntil?: number; // timestamp
  lastAttempt?: number; // timestamp
  progressiveDelay?: number;
  checksum?: string; // For additional integrity validation
}

export class RateLimitManager {
  private static readonly DEFAULT_CONFIG: RateLimitConfig = {
    maxAttempts: 5,
    lockoutDuration: 15 * 60 * 1000, // 15 minutes
    progressiveDelay: true,
    storageKey: 'auth_security_state',
    baseDelay: 1000 // 1 second base delay
  };

  private config: RateLimitConfig;

  constructor(config: Partial<RateLimitConfig> = {}) {
    this.config = { ...RateLimitManager.DEFAULT_CONFIG, ...config };
  }

  /**
   * Check the current rate limit status for an identifier
   */
  async checkRateLimit(identifier: string): Promise<RateLimitStatus> {
    try {
      const state = await this.getSecurityState(identifier);
      const now = Date.now();

      // Check if account is currently locked
      if (state.lockoutUntil && now < state.lockoutUntil) {
        // Log lockout status check
        securityLogger.logEvent(SecurityEventType.ACCOUNT_LOCKED, {
          userAgent: navigator?.userAgent,
          timestamp: new Date(),
          additionalContext: {
            userIdentifier: securityLogger['hashIdentifier'](identifier),
            component: 'RateLimitManager',
            action: 'checkRateLimit',
            lockoutActive: true,
            remainingTime: state.lockoutUntil - now,
            failedAttempts: state.failedAttempts
          }
        }, 'Rate limit check - account locked');

        return {
          isLocked: true,
          remainingTime: state.lockoutUntil - now,
          attemptsRemaining: 0,
          canAttempt: false,
          progressiveDelay: state.progressiveDelay
        };
      }

      // If lockout has expired, clean up the state
      if (state.lockoutUntil && now >= state.lockoutUntil) {
        // Log lockout expiration
        securityLogger.logEvent(SecurityEventType.LOCKOUT_EXPIRED, {
          userAgent: navigator?.userAgent,
          timestamp: new Date(),
          additionalContext: {
            userIdentifier: securityLogger['hashIdentifier'](identifier),
            component: 'RateLimitManager',
            action: 'checkRateLimit',
            lockoutExpired: true,
            previousFailedAttempts: state.failedAttempts
          }
        }, 'Account lockout expired - access restored');

        await this.resetFailedAttempts(identifier);
        return {
          isLocked: false,
          attemptsRemaining: this.config.maxAttempts,
          canAttempt: true,
          progressiveDelay: 0
        };
      }

      // Calculate remaining attempts
      const attemptsRemaining = Math.max(0, this.config.maxAttempts - state.failedAttempts);
      const progressiveDelay = this.calculateProgressiveDelay(state.failedAttempts);

      // Log rate limit status check if there are failed attempts
      if (state.failedAttempts > 0) {
        securityLogger.logEvent(SecurityEventType.RATE_LIMIT_EXCEEDED, {
          userAgent: navigator?.userAgent,
          timestamp: new Date(),
          attemptCount: state.failedAttempts,
          additionalContext: {
            userIdentifier: securityLogger['hashIdentifier'](identifier),
            component: 'RateLimitManager',
            action: 'checkRateLimit',
            attemptsRemaining,
            progressiveDelay,
            canAttempt: attemptsRemaining > 0
          }
        }, `Rate limit status check - ${state.failedAttempts} failed attempts`);
      }

      return {
        isLocked: false,
        attemptsRemaining,
        canAttempt: attemptsRemaining > 0,
        progressiveDelay
      };
    } catch (error) {
      console.error('Error checking rate limit:', error);
      
      // Log the error
      securityLogger.logSecurityError(
        SecurityEventType.STORAGE_ERROR,
        error instanceof Error ? error : new Error(String(error)),
        {
          component: 'RateLimitManager',
          action: 'checkRateLimit',
          userIdentifier: securityLogger['hashIdentifier'](identifier)
        }
      );
      
      // Return safe defaults on error
      return {
        isLocked: false,
        attemptsRemaining: this.config.maxAttempts,
        canAttempt: true,
        progressiveDelay: 0
      };
    }
  }

  /**
   * Increment failed attempts counter and check for lockout
   */
  async incrementFailedAttempts(identifier: string): Promise<void> {
    try {
      const state = await this.getSecurityState(identifier);
      const now = Date.now();

      // If already locked and lockout hasn't expired, don't increment
      if (state.lockoutUntil && now < state.lockoutUntil) {
        // Log attempt to increment while locked
        securityLogger.logEvent(SecurityEventType.RATE_LIMIT_EXCEEDED, {
          userAgent: navigator?.userAgent,
          timestamp: new Date(),
          additionalContext: {
            userIdentifier: securityLogger['hashIdentifier'](identifier),
            component: 'RateLimitManager',
            action: 'incrementFailedAttempts',
            alreadyLocked: true,
            remainingLockoutTime: state.lockoutUntil - now
          }
        }, 'Attempt to increment failed attempts while account locked');
        return;
      }

      // Increment failed attempts
      const newFailedAttempts = state.failedAttempts + 1;
      const progressiveDelay = this.calculateProgressiveDelay(newFailedAttempts);

      const newState: SecurityState = {
        failedAttempts: newFailedAttempts,
        lastAttempt: now,
        progressiveDelay
      };

      // Check if we should activate lockout
      const shouldLockout = newFailedAttempts >= this.config.maxAttempts;
      if (shouldLockout) {
        newState.lockoutUntil = now + this.config.lockoutDuration;
        
        // Log account lockout activation
        securityLogger.logAccountLocked(
          identifier,
          this.config.lockoutDuration,
          newFailedAttempts
        );
      } else {
        // Log failed attempt increment
        securityLogger.logEvent(SecurityEventType.FAILED_LOGIN, {
          userAgent: navigator?.userAgent,
          timestamp: new Date(),
          attemptCount: newFailedAttempts,
          additionalContext: {
            userIdentifier: securityLogger['hashIdentifier'](identifier),
            component: 'RateLimitManager',
            action: 'incrementFailedAttempts',
            attemptsRemaining: this.config.maxAttempts - newFailedAttempts,
            progressiveDelay,
            lockoutPending: newFailedAttempts === this.config.maxAttempts - 1
          }
        }, `Failed attempt ${newFailedAttempts} of ${this.config.maxAttempts}`);
      }

      await this.setSecurityState(identifier, newState);
    } catch (error) {
      console.error('Error incrementing failed attempts:', error);
      
      // Log the error
      securityLogger.logSecurityError(
        SecurityEventType.STORAGE_ERROR,
        error instanceof Error ? error : new Error(String(error)),
        {
          component: 'RateLimitManager',
          action: 'incrementFailedAttempts',
          userIdentifier: securityLogger['hashIdentifier'](identifier)
        }
      );
      
      throw new Error('Failed to update security state');
    }
  }

  /**
   * Reset failed attempts counter (called on successful authentication)
   */
  async resetFailedAttempts(identifier: string): Promise<void> {
    try {
      const currentState = await this.getSecurityState(identifier);
      
      // Log reset if there were previous failed attempts
      if (currentState.failedAttempts > 0 || currentState.lockoutUntil) {
        securityLogger.logEvent(SecurityEventType.SUCCESSFUL_LOGIN, {
          userAgent: navigator?.userAgent,
          timestamp: new Date(),
          additionalContext: {
            userIdentifier: securityLogger['hashIdentifier'](identifier),
            component: 'RateLimitManager',
            action: 'resetFailedAttempts',
            previousFailedAttempts: currentState.failedAttempts,
            wasLocked: !!currentState.lockoutUntil,
            lockoutCleared: !!currentState.lockoutUntil
          }
        }, 'Security state reset after successful authentication');
      }
      
      await this.clearSecurityState(identifier);
    } catch (error) {
      console.error('Error resetting failed attempts:', error);
      
      // Log the error
      securityLogger.logSecurityError(
        SecurityEventType.STORAGE_ERROR,
        error instanceof Error ? error : new Error(String(error)),
        {
          component: 'RateLimitManager',
          action: 'resetFailedAttempts',
          userIdentifier: securityLogger['hashIdentifier'](identifier)
        }
      );
      
      throw new Error('Failed to reset security state');
    }
  }

  /**
   * Check if account is currently locked
   */
  async isAccountLocked(identifier: string): Promise<boolean> {
    try {
      const status = await this.checkRateLimit(identifier);
      return status.isLocked;
    } catch (error) {
      console.error('Error checking account lock status:', error);
      return false; // Fail open for availability
    }
  }

  /**
   * Get remaining lockout time in milliseconds
   */
  async getRemainingLockoutTime(identifier: string): Promise<number> {
    try {
      const status = await this.checkRateLimit(identifier);
      return status.remainingTime || 0;
    } catch (error) {
      console.error('Error getting remaining lockout time:', error);
      return 0;
    }
  }

  /**
   * Calculate progressive delay based on failed attempts
   */
  private calculateProgressiveDelay(failedAttempts: number): number {
    if (!this.config.progressiveDelay || failedAttempts <= 0) {
      return 0;
    }

    const baseDelay = this.config.baseDelay || 1000;
    // Exponential backoff: baseDelay * 2^(attempts-1), capped at 30 seconds
    const delay = baseDelay * Math.pow(2, Math.min(failedAttempts - 1, 5));
    return Math.min(delay, 30000);
  }

  /**
   * Validate lockout time calculation
   */
  validateLockoutTime(lockoutUntil: number): boolean {
    const now = Date.now();
    const maxValidLockout = now + (24 * 60 * 60 * 1000); // 24 hours max
    
    return lockoutUntil > now && lockoutUntil <= maxValidLockout;
  }

  /**
   * Get security state from security state manager
   */
  private async getSecurityState(identifier: string): Promise<SecurityState> {
    try {
      const stateRecord = await securityStateManager.getSecurityState(identifier);
      
      if (!stateRecord) {
        return this.getDefaultSecurityState();
      }

      // Convert SecurityStateRecord to SecurityState
      return {
        failedAttempts: stateRecord.failedAttempts,
        lockoutUntil: stateRecord.lockoutUntil,
        lastAttempt: stateRecord.lastAttempt,
        progressiveDelay: stateRecord.progressiveDelay
      };
    } catch (error) {
      console.error('Error retrieving security state:', error);
      return this.getDefaultSecurityState();
    }
  }

  /**
   * Set security state using security state manager
   */
  private async setSecurityState(identifier: string, state: SecurityState): Promise<void> {
    try {
      await securityStateManager.setSecurityState(identifier, {
        failedAttempts: state.failedAttempts,
        lockoutUntil: state.lockoutUntil,
        lastAttempt: state.lastAttempt,
        progressiveDelay: state.progressiveDelay
      });
    } catch (error) {
      console.error('Error storing security state:', error);
      throw new Error('Failed to store security state');
    }
  }

  /**
   * Clear security state using security state manager
   */
  private async clearSecurityState(identifier: string): Promise<void> {
    try {
      await securityStateManager.clearSecurityState(identifier);
    } catch (error) {
      console.error('Error clearing security state:', error);
      throw new Error('Failed to clear security state');
    }
  }

  /**
   * Get default security state
   */
  private getDefaultSecurityState(): SecurityState {
    return {
      failedAttempts: 0,
      progressiveDelay: 0
    };
  }

  /**
   * Clean up expired lockout states
   */
  async cleanupExpiredStates(): Promise<void> {
    try {
      // Delegate to security state manager
      await securityStateManager.cleanupExpiredStates();
    } catch (error) {
      console.error('Error cleaning up expired states:', error);
    }
  }

  /**
   * Add state change listener for cross-tab synchronization
   */
  addStateChangeListener(identifier: string, callback: (state: SecurityState | null) => void): void {
    securityStateManager.addStateChangeListener(identifier, (stateRecord) => {
      if (stateRecord) {
        const state: SecurityState = {
          failedAttempts: stateRecord.failedAttempts,
          lockoutUntil: stateRecord.lockoutUntil,
          lastAttempt: stateRecord.lastAttempt,
          progressiveDelay: stateRecord.progressiveDelay
        };
        callback(state);
      } else {
        callback(null);
      }
    });
  }

  /**
   * Remove state change listener
   */
  removeStateChangeListener(identifier: string, callback: (state: SecurityState | null) => void): void {
    // Note: This is a simplified implementation. In a real scenario, you'd need to track
    // the wrapper functions to properly remove listeners.
    console.warn('removeStateChangeListener not fully implemented - use cleanup() instead');
  }

  /**
   * Get current configuration
   */
  getConfig(): RateLimitConfig {
    return { ...this.config };
  }

  /**
   * Update configuration
   */
  updateConfig(newConfig: Partial<RateLimitConfig>): void {
    this.config = { ...this.config, ...newConfig };
  }
}

// Export a default instance for convenience
export const rateLimitManager = new RateLimitManager();

// Export types for external use
export type { RateLimitStatus, RateLimitConfig, SecurityState };